// styles:
import "./Create.css";

import { useState } from "react";
import { useFirestore } from "../../hooks/useFirestore";

import Tags from "../../components/tags/Tags";

export default function Create() {
  const { addBlog, error, isPending } = useFirestore("users");
  const [title, setTitle] = useState("");
  const [author, setAuthor] = useState("");
  const [dateStarted, setDateStarted] = useState("");
  const [dateFinished, setDateFinished] = useState("");
  const [tags, setTags] = useState("");
  const [content, setContent] = useState("");

  const handleTags = (e) => {
    if (e.target.checked === true) {
      setTags([...tags, e.target.value]);
    } else {
      let reducedTags = tags.filter((tag) => tag !== e.target.value);
      setTags(reducedTags);
    }
  };

  return (
    <div className="create">
      <h2>Create a New Blog</h2>
      <form id="create-form">
        <div className="form-row">
          <label htmlFor="bookTitle">Title:</label>

          <input
            id="bookTitle"
            name="bookTitle"
            type="text"
            onChange={(e) => setTitle(e.target.value)}
            value={title}
            required="required"
          />
        </div>

        <div className="form-row">
          <label htmlFor="author">Author:</label>
          <input
            id="author"
            name="author"
            type="text"
            onChange={(e) => setAuthor(e.target.value)}
            value={author}
            required="required"
          />
        </div>
        <div className="form-row">
          <label htmlFor="dateStarted">Started:</label>
          <input
            id="dateStarted"
            name="dateStarted"
            type="date"
            min="1992-11-16"
            max="2092-11-16"
            onChange={(e) => setDateStarted(e.target.value)}
            value={dateStarted}
          />
        </div>

        <div className="form-row">
          <label htmlFor="dateFinished">Finished:</label>
          <input
            id="dateFinished"
            name="dateFinished"
            type="date"
            min="1992-11-16"
            max="2092-11-16"
            onChange={(e) => setDateFinished(e.target.value)}
            value={dateFinished}
          />
        </div>

        <Tags handleTags={handleTags}/>

        {/* <div className="form-row-full">
          <fieldset>
            <legend>Tags:</legend>
            <div className="tag-option">
              <input type="checkbox" id="sci-fi" name="tags" value="Sci-fi" />
              <label htmlFor="sci-fi">Sci-fi</label>
            </div>
            <div className="tag-option">
              <input type="checkbox" id="fantasy" name="tags" value="Fantasy" />
              <label htmlFor="fantasy">Fantasy</label>
            </div>
            <div className="tag-option">
              <input
                type="checkbox"
                id="informative"
                name="tags"
                value="Informative"
              />
              <label htmlFor="informative">Informative</label>
            </div>
            <div className="tag-option">
              <input type="checkbox" id="fiction" name="tags" value="Fiction" />
              <label htmlFor="fiction">Fiction</label>
            </div>
            <div className="tag-option">
              <input
                type="checkbox"
                id="short-story"
                name="tags"
                value="Short Story"
              />
              <label htmlFor="short-story">Short Story</label>
            </div>
            <div className="tag-option">
              <input
                type="checkbox"
                id="non-fiction"
                name="tags"
                value="Non-fiction"
              />
              <label htmlFor="non-fiction">Non-Fiction</label>
            </div>
            <div className="tag-option">
              <input
                type="checkbox"
                id="biography"
                name="tags"
                value="Biography"
              />
              <label htmlFor="biography">Biography</label>
            </div>
            <div className="tag-option">
              <input
                type="checkbox"
                id="classical"
                name="tags"
                value="Classical"
              />
              <label htmlFor="classical">Classical</label>
            </div>
            <div className="tag-option">
              <input type="checkbox" id="comedy" name="tags" value="Comedy" />
              <label htmlFor="comedy">Comedy</label>
            </div>
            <div className="tag-option">
              <input type="checkbox" id="horror" name="tags" value="Horror" />
              <label htmlFor="horror">Horror</label>
            </div>
          </fieldset>
        </div> */}

        <div className="form-row-full">
          <label htmlFor="blogContent">Thoughts on the Book:</label>
        </div>

        <textarea id="blogContent" name="blogContent"></textarea>
      </form>
      <button form="create-form">Post!</button>
    </div>
  );
}


/////////////////////////////////


import "./Home.css";

import { Link } from "react-router-dom";

import EditButton from "../../assets/EditButton";

export default function BlogCard({ blogs }) {
  const generateNewLines = (blog) => {
    const reg = /\n/;
    let blogSnippet = [];
    blogSnippet.push(blog.content.split(reg));

    return blogSnippet;
  };

  return (
    <>
      {blogs.map((blog) => (
        <div key={blog.title} className="content-box">
          <div className="top-container">
            <div className="card-col card-col-1">
              <div className="card-line title-line">
                <Link className="title" to="#">
                  <h1 className="title">{blog.title}</h1>
                </Link>

                <Link to="#">
                  <EditButton className="edit" />
                </Link>
              </div>

              {blog.author && (
                <div className="card-line author-line">
                  <p className="author">
                    by
                    <Link className="authorLink" to="#">
                      {blog.author}
                    </Link>
                  </p>

                  <Link to="#">
                    <EditButton className="edit" />
                  </Link>
                </div>
              )}

              {blog.dateStarted && (
                <div className="card-line date-space">
                  <div className="dateStarted">
                    <p className="date-label">Started:</p>
                    <p className="date-value">{blog.dateStarted}</p>
                  </div>

                  <div className="dateFinished">
                    <p className="date-label">Finished:</p>
                    <div className="date-value">
                      {blog.dateFinished === "" ? (
                        <p>Currently Reading</p>
                      ) : (
                        <p>{blog.dateFinished}</p>
                      )}
                    </div>
                  </div>
                </div>
              )}

              {blog.tags && (
                <div className="card-line tags">
                  <p className="tags-label">Tags:</p>
                  {blog.tags.length === 0 ? (
                    <p className="tags-value">No Tags.</p>
                  ) : (
                    blog.tags.map((tag) => (
                      <p>
                        <Link to="#">{tag}</Link>
                      </p>
                    ))
                  )}
                </div>
              )}
            </div>

            {/* {blog.image && (
              <div className="card-col card-col-2">
                <img
                  className="card-image"
                  src="./images/test-image-opt.svg"
                  alt="Some stylized purple outlined trees on a dark landscape."
                />
              </div>
            )} */}
          </div>

          {/* {blog.content && (
            <div className="card-line-full">
              <div className="blog-snippet">
                {generateNewLines(blog.content).map((line) => (
                  <p className="snips">{line}</p>
                ))}
              </div>
            </div>
          )} */}
        </div>
      ))}
    </>
  );
}


/////////////

 const examineUpdate = async (updatedData) => {
    try {
      // checkIfAuthorExists retrieves the authorDoc if author exists
      // else it returns a freshly made authorDoc
      const authorDocRef = await checkIfAuthorExists(updatedData);
      let prevAuthorID = updatedData.authorID;
      let updatedAuthorID = authorDocRef.id;

      const { docRef: blogDocRef, docData: blogDocData } =
        await getDocRefOrData(blogsCollection, updatedData.id);
      const { docRef: prevKeyDocRef, docData: prevKeyDocData } =
        await getDocRefOrData(keysCollection, prevAuthorID);

      let prevKeyTitle = { [blogDocData.title]: blogDocRef.id };

      let didTitleChange = blogDocData.title !== updatedData.title;
      let didAuthorChange = blogDocData.author !== updatedData.author;

      switch (didTitleChange) {
        case true:
          switch (didAuthorChange) {
            case true:
              console.log("Author name has been changed.");
              changeAuthorName(
                authorDocRef,
                updatedData,
                blogDocData,
                blogDocRef
              );
              changeKeyData(updatedData, authorDocRef, blogDocData, blogDocRef);
              break;
            case false:
              console.log("Author name has NOT been changed.");

              const updatedBlog = await updateDoc(blogDocRef, updatedData);
              dispatchIfNotCancelled({
                type: "UPDATED_BLOG",
                payload: updatedBlog,
              });

              let updatedAuthor = await updateDoc(authorDocRef, {
                booksWritten: arrayRemove(blogDocData.title),
              });
              updatedAuthor = await updateDoc(authorDocRef, {
                booksWritten: arrayUnion(updatedData.title),
              });
              dispatchIfNotCancelled({
                type: "UPDATED_AUTHOR",
                payload: updatedAuthor,
              });
              break;
            default:
              console.log("Something went wrong");
          }
          break;
        case false:
          switch (didAuthorChange) {
            case true:
              console.log("Book title has NOT been changed.");
              // Condition 3: Title DOES NOT Change & Author Name Changes:
              if (blogDocData.author !== updatedData.author) {
                console.log("Author name has been changed.");
                changeAuthorName(
                  authorDocRef,
                  updatedData,
                  blogDocData,
                  blogDocRef
                );
              }
              break;
            case false:
              // Condition 4: Title DOES NOT Change & Author Name DOES NOT Change:
              console.log("Author name has NOT been changed.");
              const updatedBlog = await updateDoc(blogDocRef, updatedData);
              dispatchIfNotCancelled({
                type: "UPDATED_BLOG",
                payload: updatedBlog,
              });
              break;
            default:
              console.log("Something went wrong");
          }
          break;
        default:
          console.log("Something went wrong");
      }
    } catch (err) {
      dispatchIfNotCancelled({ type: "ERROR", payload: err.message });
    }
  };

  ------------------------
  
  // const changeKeyData = async (prevKeyDocRef, prevKeyDocData, prevKeyTitle) => {

  //   // let updatedAuthorID = authorDocRef.id;
  //   // let prevAuthorID = updatedData.authorID;
  //   // let prevKeyTitle = { [blogDocData.title]: blogDocRef.id }

  //   // // previous key doc:
  //   // const prevKeyDocRef = doc(keysCollection, prevAuthorID)
  //   // const prevKeyDocSnap = await getDoc(prevKeyDocRef)
  //   // const prevKeyDocData = prevKeyDocSnap.data();

  //   // Condition 3a: author has written multiple books
  //   if (prevKeyDocData.booksWithIDs.length > 1) {
  //     let updatedPrevKey = await updateDoc(prevKeyDocRef, {
  //       booksWithIDs: arrayRemove(prevKeyTitle),
  //     });
  //     dispatchIfNotCancelled({
  //       type: "UPDATED_KEY",
  //       payload: updatedPrevKey,
  //     });
  //   }
  //   // Condition 3b: author has only written the book being edited
  //   else {
  //     await deleteDoc(prevKeyDocRef);
  //   }
  // };

  ------------------

    const changeAuthorName = async (
    authorDocRef,
    updatedData,
    blogDocData,
    blogDocRef,
    prevAuthorDocRef,
    prevAuthorDocData
  ) => {
    let updatedAuthorID = authorDocRef.id;

    // const prevAuthorDocRef = doc(authorsCollection, updatedData.authorID);
    // const prevAuthorDocSnap = await getDoc(prevAuthorDocRef);
    // const prevAuthorDocData = prevAuthorDocSnap.data();

    // Condition 3a: author has written multiple books
    console.log(prevAuthorDocData);
    if (prevAuthorDocData.booksWritten.length > 1) {
      let updatedPrevAuthor = await updateDoc(prevAuthorDocRef, {
        booksWritten: arrayRemove(blogDocData.title),
      });
      dispatchIfNotCancelled({
        type: "UPDATED_AUTHOR",
        payload: updatedPrevAuthor,
      });
    }
    // Condition 3b: author has only written the book being edited
    else {
      await deleteDoc(prevAuthorDocRef);
    }

    // give blog doc new authorID:
    const updatedBlog = await updateDoc(blogDocRef, {
      ...updatedData,
      authorID: updatedAuthorID,
    });
    dispatchIfNotCancelled({
      type: "UPDATED_BLOG",
      payload: updatedBlog,
    });
  };

-----------------

  const checkIfAuthorExists = async (blog) => {
    dispatch({ type: "IS_PENDING" });

    try {
      let queryRules = ["name", "==", blog.author];
      const authorDoc = await locateDoc(authorsCollection, queryRules);

      // update authorDoc & return updated authorDocRef
      if (authorDoc.docs.length > 0) {
        console.log("author exists");

        const authorDocID = authorDoc.docs[0].id;
        const authorDocRef = doc(authorsCollection, authorDocID);

        await updateAuthor(authorDocRef, blog);
        return authorDocRef;
      }
      // add authorDoc & return new authorDocRef
      else {
        console.log("author does not exist");

        const authorDocRef = await addAuthor(blog);
        console.log(authorDocRef);
        return authorDocRef;
      }
    } catch (err) {
      dispatchIfNotCancelled({ type: "ERROR", payload: err.message });
    }
  };

/////////////
Condition 1: Title Changes & Author Name Changes:
  1. Is this a newAuthor?
    Yes - 
      newAuthor generates newKey with newAuthorID ->
        newAuthorName
        newAuthorID
        prevAboutAuthor ???
        [{newBookTitle: newBookID}] 
    No - 
      add newKeyData to existingAuthorKey with existingAuthorKeyID ->
        arrayUnion([{newBookTitle: newBookID}])
        confirm: merge prevAboutAuthor with existingAboutAuthor?
          Yes - 
            merge prevAboutAuthor with existingAboutAuthor
          No - 
            do not merge prevAboutAuthor data
  2. Was prevBookTitle the only book prevAuthor wrote?
    Yes -
      delete prevKey
    No -
      arrayRemove(prevKey)

Condition 2: Title Changes & Author Name DOES NOT Change:
  1. replace prevKey data
    arrayRemove( [{prevBookTitle: prevBookID}] )
    arrayUnion([{newBookTitle: prevBookID}])
Condition 3: Title DOES NOT Change & Author Name Changes:
  1. Is this a newAuthor?
    Yes - 
      newAuthor generates newKey with newAuthorID ->
        newAuthorName
        newAuthorID
        [{prevBookTitle: prevBookID}] 

        confirm: keep prevAboutAuthor with newAboutAuthor? 
          Yes - 
            add prevAboutAuthor
          No -
            add empty string
    No - 
      add newKeyData to existingAuthorKey with existingAuthorKeyID ->
        arrayUnion([{prevBookTitle: prevBookID}])
        confirm: merge prevAboutAuthor with existingAboutAuthor?
          Yes - 
            merge prevAboutAuthor with existingAboutAuthor
          No - 
            do not merge prevAboutAuthor data
  2. Was prevBookTitle the only book prevAuthor wrote?
    Yes -
      delete prevKey
    No -
      arrayRemove(prevKey)
Condition 4: Title DOES NOT Change & Author Name DOES NOT Change:
  if aboutAuthor changed, 
    add to newKeyData
  else 
    do nothing